#!/usr/bin/env python3
"""
Web-only Flask app for Poppalyze
No background scanner - only serves the web interface
"""

import os
import sys
import json
import time
import logging
import threading
import hashlib
import secrets
from pathlib import Path
from contextlib import contextmanager
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from enum import Enum
from functools import wraps

from flask import Flask, render_template, request, jsonify, redirect, url_for, session, flash
import yfinance as yf
import uuid

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# =====================================================
# CONFIGURATION
# =====================================================

CACHE_FILE = Path("stock_cache.json")
SCANNER_INTERVAL = 300  # 5 minutes

# Admin configuration - set these as environment variables in Render
ADMIN_USERNAME = os.environ.get('ADMIN_USERNAME', 'admin')
ADMIN_PASSWORD_HASH = os.environ.get('ADMIN_PASSWORD_HASH', '')
ADMIN_SECRET_KEY = os.environ.get('ADMIN_SECRET_KEY', secrets.token_hex(32))

# =====================================================
# DATA STRUCTURES
# =====================================================

class Sector(Enum):
    TECHNOLOGY = "Technology"
    HEALTHCARE = "Healthcare"
    FINANCIAL = "Financial"
    CONSUMER = "Consumer"
    INDUSTRIAL = "Industrial"
    ENERGY = "Energy"
    MATERIALS = "Materials"
    UTILITIES = "Utilities"
    REAL_ESTATE = "Real Estate"
    COMMUNICATION = "Communication"

@dataclass
class StockData:
    symbol: str
    price: float
    previous_close: float
    gap_pct: float
    volume: int
    relative_volume: float
    market_cap_formatted: str
    volume_formatted: str
    category: str
    pre_market_price: Optional[float] = None
    pre_market_change_pct: Optional[float] = None
    post_market_price: Optional[float] = None
    post_market_change_pct: Optional[float] = None
    gap_classification: str = ""

# =====================================================
# AUTHENTICATION
# =====================================================

def hash_password(password: str) -> str:
    """Hash a password using SHA-256"""
    return hashlib.sha256(password.encode()).hexdigest()

def verify_password(password: str, hashed: str) -> bool:
    """Verify a password against its hash"""
    return hash_password(password) == hashed

def login_required(f):
    """Decorator to require admin login"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not session.get('admin_logged_in'):
            flash('Please log in to access admin panel', 'error')
            return redirect(url_for('admin_login'))
        return f(*args, **kwargs)
    return decorated_function

# =====================================================
# CACHE MANAGEMENT
# =====================================================

class CacheManager:
    def __init__(self):
        self.cache: Dict = {}
        self.cache_lock = threading.RLock()
        
    def load_cache(self) -> None:
        """Load cache from file"""
        try:
            if CACHE_FILE.exists():
                with open(CACHE_FILE, 'r') as f:
                    cache_data = json.load(f)
                
                # Reconstruct StockData objects from dictionaries
                stocks_dict = cache_data.get('stocks', {})
                reconstructed_stocks = {}
                
                for symbol, stock_dict in stocks_dict.items():
                    if isinstance(stock_dict, dict):
                        # Filter out any fields that don't belong in StockData
                        valid_fields = {
                            'symbol', 'price', 'previous_close', 'gap_pct', 'volume', 
                            'relative_volume', 'market_cap_formatted', 'volume_formatted', 
                            'category', 'pre_market_price', 'pre_market_change_pct', 
                            'post_market_price', 'post_market_change_pct', 'gap_classification'
                        }
                        
                        # Only include valid fields
                        filtered_dict = {k: v for k, v in stock_dict.items() if k in valid_fields}
                        
                        # Convert dictionary back to StockData object
                        try:
                            stock_data = StockData(**filtered_dict)
                            reconstructed_stocks[symbol] = stock_data
                        except Exception as e:
                            logger.warning(f"‚ö†Ô∏è Error reconstructing {symbol}: {e}")
                            continue
                    else:
                        # Already a StockData object (from old cache format)
                        reconstructed_stocks[symbol] = stock_dict
                
                # Update cache with reconstructed data
                self.cache = {
                    'stocks': reconstructed_stocks,
                    'last_update': cache_data.get('last_update'),
                    'scan_count': cache_data.get('scan_count'),
                    'scan_type': cache_data.get('scan_type')
                }
                
                logger.info(f"‚úÖ Cache loaded with {len(reconstructed_stocks)} stocks")
            else:
                logger.warning("‚ö†Ô∏è No cache file found")
                self.cache = {'stocks': {}, 'last_update': None, 'scan_count': 0, 'scan_type': None}
                
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error loading cache: {e}")
            self.cache = {'stocks': {}, 'last_update': None, 'scan_count': 0, 'scan_type': None}
    
    @contextmanager
    def get_cache(self):
        """Thread-safe cache access"""
        with self.cache_lock:
            yield self.cache

# =====================================================
# FLASK APP
# =====================================================

app = Flask(__name__)
app.secret_key = ADMIN_SECRET_KEY

# Initialize cache manager
cache_manager = CacheManager()

# =====================================================
# ADMIN ROUTES
# =====================================================

@app.route("/admin/login", methods=['GET', 'POST'])
def admin_login():
    """Admin login page"""
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if username == ADMIN_USERNAME and verify_password(password, ADMIN_PASSWORD_HASH):
            session['admin_logged_in'] = True
            session['admin_username'] = username
            flash('Successfully logged in!', 'success')
            return redirect(url_for('admin_dashboard'))
        else:
            flash('Invalid username or password', 'error')
    
    return render_template('admin_login.html')

@app.route("/admin/logout")
def admin_logout():
    """Admin logout"""
    session.pop('admin_logged_in', None)
    session.pop('admin_username', None)
    flash('Successfully logged out!', 'success')
    return redirect(url_for('admin_login'))

@app.route("/admin")
@login_required
def admin_dashboard():
    """Admin dashboard"""
    try:
        with cache_manager.get_cache() as cache_data:
            stats = {
                'total_stocks': len(cache_data.get('stocks', {})),
                'last_update': cache_data.get('last_update', 'Never'),
                'scan_count': cache_data.get('scan_count', 0),
                'scan_type': cache_data.get('scan_type', 'Unknown')
            }
            
            # Get some sample stocks for display
            stocks = list(cache_data.get('stocks', {}).values())[:10]
            
            return render_template('admin_dashboard.html', stats=stats, stocks=stocks)
    except Exception as e:
        flash(f'Error loading dashboard: {e}', 'error')
        return render_template('admin_dashboard.html', stats={}, stocks=[])

@app.route("/admin/cache")
@login_required
def admin_cache():
    """Admin cache management"""
    try:
        with cache_manager.get_cache() as cache_data:
            cache_info = {
                'file_exists': CACHE_FILE.exists(),
                'file_size': CACHE_FILE.stat().st_size if CACHE_FILE.exists() else 0,
                'last_modified': datetime.fromtimestamp(CACHE_FILE.stat().st_mtime) if CACHE_FILE.exists() else None,
                'total_stocks': len(cache_data.get('stocks', {})),
                'last_update': cache_data.get('last_update'),
                'scan_count': cache_data.get('scan_count', 0)
            }
            
            return render_template('admin_cache.html', cache_info=cache_info)
    except Exception as e:
        flash(f'Error loading cache info: {e}', 'error')
        return render_template('admin_cache.html', cache_info={})

@app.route("/admin/settings")
@login_required
def admin_settings():
    """Admin settings page"""
    settings = {
        'admin_username': ADMIN_USERNAME,
        'cache_file': str(CACHE_FILE),
        'scanner_interval': SCANNER_INTERVAL,
        'app_version': '1.0.0'
    }
    
    return render_template('admin_settings.html', settings=settings)

@app.route("/admin/api/refresh_cache")
@login_required
def admin_refresh_cache():
    """API endpoint to refresh cache"""
    try:
        cache_manager.load_cache()
        flash('Cache refreshed successfully!', 'success')
        return jsonify({'status': 'success', 'message': 'Cache refreshed'})
    except Exception as e:
        flash(f'Error refreshing cache: {e}', 'error')
        return jsonify({'status': 'error', 'message': str(e)}), 500

# =====================================================
# PUBLIC ROUTES
# =====================================================

@app.route("/")
def screener():
    """Main screener page"""
    logger.info("üìÑ Main screener page requested")
    
    try:
        # Get cache data
        with cache_manager.get_cache() as cache_data:
            if not cache_data or not cache_data.get('stocks'):
                logger.warning("‚ö†Ô∏è No cache data available for main page")
                return render_template('screener.html', 
                                     stocks=[],
                                     cache_status={'status': 'No data', 'stock_count': 0, 'age_minutes': 0.0},
                                     filters={})
            
            stocks = list(cache_data['stocks'].values())
            
            # Apply filters
            filters = get_filters_from_request()
            filtered_stocks = apply_filters(stocks, filters)
            
            # Get cache status
            cache_status = get_cache_status(cache_data)
            
            logger.info(f"‚úÖ Main page rendered with {len(filtered_stocks)} filtered stocks")
            
            return render_template('screener.html', 
                                 stocks=filtered_stocks,
                                 cache_status=cache_status,
                                 filters=filters)
                                 
    except Exception as e:
        logger.error(f"‚ùå Error rendering main page: {e}")
        return render_template('screener.html', 
                             stocks=[],
                             cache_status={'status': 'Error', 'stock_count': 0, 'age_minutes': 0.0},
                             filters={})

@app.route("/health")
def health():
    """Health check endpoint"""
    try:
        with cache_manager.get_cache() as cache_data:
            stock_count = len(cache_data.get('stocks', {}))
            last_update = cache_data.get('last_update')
            
            if last_update:
                age_minutes = (datetime.now() - datetime.fromisoformat(last_update)).total_seconds() / 60
            else:
                age_minutes = 0
            
            return jsonify({
                'status': 'healthy',
                'stock_count': stock_count,
                'age_minutes': round(age_minutes, 1),
                'timestamp': datetime.now().isoformat()
            })
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 500

@app.route("/api/cache_status")
def api_cache_status():
    """Get cache status"""
    try:
        with cache_manager.get_cache() as cache_data:
            if not cache_data:
                return jsonify({
                    'status': 'no_data',
                    'message': 'No cache data available',
                    'age_minutes': 0,
                    'is_fresh': False,
                    'last_update_str': 'Never',
                    'successful_count': 0,
                    'total_count': 0,
                    'last_update': 'Never',
                    'stocks_available': 0
                })
            
            last_update = cache_data.get('last_update')
            if last_update:
                last_update_dt = datetime.fromisoformat(last_update)
                age_minutes = (datetime.now() - last_update_dt).total_seconds() / 60
                last_update_str = last_update_dt.strftime('%Y-%m-%d %H:%M:%S')
                is_fresh = age_minutes < 10  # Consider fresh if less than 10 minutes old
            else:
                age_minutes = 0
                last_update_str = 'Never'
                is_fresh = False
            
            stock_count = len(cache_data.get('stocks', {}))
            
            return jsonify({
                'status': 'success',
                'message': 'Cache data available',
                'age_minutes': round(age_minutes, 1),
                'is_fresh': is_fresh,
                'last_update_str': last_update_str,
                'successful_count': cache_data.get('scan_count', 0),
                'total_count': cache_data.get('scan_count', 0),
                'last_update': last_update_str,
                'stocks_available': stock_count
            })
    except Exception as e:
        return jsonify({
            'status': 'error',
            'message': f'Error loading cache: {str(e)}',
            'age_minutes': 0,
            'is_fresh': False,
            'last_update_str': 'Error',
            'successful_count': 0,
            'total_count': 0,
            'last_update': 'Error',
            'stocks_available': 0
        })

# =====================================================
# HELPER FUNCTIONS
# =====================================================

def get_filters_from_request():
    """Extract filters from request parameters"""
    filters = {}
    
    # Price filters
    min_price = request.args.get('min_price', type=float)
    max_price = request.args.get('max_price', type=float)
    if min_price is not None:
        filters['min_price'] = min_price
    if max_price is not None:
        filters['max_price'] = max_price
    
    # Gap filters
    min_gap_pct = request.args.get('min_gap_pct', type=float)
    if min_gap_pct is not None:
        filters['min_gap_pct'] = min_gap_pct
    
    # Volume filters
    min_rel_vol = request.args.get('min_rel_vol', type=float)
    if min_rel_vol is not None:
        filters['min_rel_vol'] = min_rel_vol
    
    # Sector filter
    sector_filter = request.args.get('sector_filter', 'All')
    if sector_filter and sector_filter != 'All':
        filters['sector_filter'] = sector_filter
    
    return filters

def apply_filters(stocks: List[StockData], filters: Dict) -> List[StockData]:
    """Apply filters to stock list"""
    filtered_stocks = stocks
    
    # Price filters
    if 'min_price' in filters:
        filtered_stocks = [s for s in filtered_stocks if s.price >= filters['min_price']]
    
    if 'max_price' in filters:
        filtered_stocks = [s for s in filtered_stocks if s.price <= filters['max_price']]
    
    # Gap filter
    if 'min_gap_pct' in filters:
        filtered_stocks = [s for s in filtered_stocks if s.gap_pct >= filters['min_gap_pct']]
    
    # Volume filter
    if 'min_rel_vol' in filters:
        filtered_stocks = [s for s in filtered_stocks if s.relative_volume >= filters['min_rel_vol']]
    
    # Sector filter
    if 'sector_filter' in filters:
        filtered_stocks = [s for s in filtered_stocks if s.category == filters['sector_filter']]
    
    return filtered_stocks

def get_cache_status(cache_data: Dict) -> Dict:
    """Get cache status information"""
    last_update = cache_data.get('last_update')
    if last_update:
        last_update_dt = datetime.fromisoformat(last_update)
        age_minutes = (datetime.now() - last_update_dt).total_seconds() / 60
        last_update_str = last_update_dt.strftime('%Y-%m-%d %H:%M:%S')
    else:
        age_minutes = 0
        last_update_str = 'Never'
    
    return {
        'status': 'active' if age_minutes < 60 else 'stale',
        'stock_count': len(cache_data.get('stocks', {})),
        'age_minutes': round(age_minutes, 1),
        'last_update': last_update_str
    }

# =====================================================
# INITIALIZATION
# =====================================================

def initialize_app():
    """Initialize the web application"""
    logger.info("üöÄ Initializing web-only Flask app...")
    
    # Ensure cache directory exists
    CACHE_FILE.parent.mkdir(parents=True, exist_ok=True)
    
    # Load cache
    try:
        cache_manager.load_cache()
        logger.info("‚úÖ Cache loaded successfully")
    except Exception as e:
        logger.error(f"‚ùå Failed to load cache: {e}")
    
    logger.info("‚úÖ Web app initialization complete")

# Initialize the app
initialize_app()

if __name__ == '__main__':
    import os
    
    # Get port from environment variable (Render sets PORT)
    port = int(os.environ.get('PORT', 5001))
    
    logger.info("üåê Starting web-only Flask server...")
    logger.info(f"üìä App will be available at: http://localhost:{port}")
    logger.info("üõë Press Ctrl+C to stop")
    
    # Production settings
    debug_mode = os.environ.get('FLASK_DEBUG', 'false').lower() == 'true'
    
    app.run(host='0.0.0.0', port=port, debug=debug_mode) 